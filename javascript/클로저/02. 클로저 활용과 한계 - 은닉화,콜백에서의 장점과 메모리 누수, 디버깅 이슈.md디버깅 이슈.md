## 클로저의 활용 예시와 단점

- ### 데이터 은닉 / 캡슐화
  - 외부에서 직접 접근할 수 없는 private 변수처럼 사용 가능

```js
function createCounter() {
  let count = 0; // 외부 함수의 변수

  return {
    increase() {
      count++;
      return count;
    },
    decrease() {
      count--;
      return count;
    },
  };
}

const counter = createCounter();
console.log(counter.increase()); // 1
console.log(counter.count); // undefined
```

- ### 상태 유지
  - 콜백에서의 상태 유지

```js
function createLogger() {
  let logs = [];

  return function (message) {
    logs.push(message);
    console.log('Logs:', logs);
  };
}

const logger = createLogger();
logger('Start process');
// Logs: ["Start process”]

logger('Process running');
// Logs: ["Start process", "Process running"]
```

- ### 클로저의 단점
  - 메모리 사용 증가: 참조가 유지되어 불필요한 데이터가 해제되지 않을 수 있음
  - 디버깅 어려움: 변수 값이 어디에서 유지/변경되는지 추적이 복잡함
  - 코드 복잡성: 과도한 중첩 사용 시 가독성과 유지보수성 저하

## 정리

- 클로저는 데이터 은닉과 상태 유지 같은 장점을 제공하지만 메모리나 복잡성 문제도 있기 때문에 꼭 필요한 경우에만 신중하게 사용하는 것이 좋음
