## async, await

- Promise 기반의 비동기 코드를 <span style='color:skyBlue'>더 직관적이고 동기적으로</span> 보이게
  작성할 수 있도록 도와주는 문법

## async 키워드

- 함수 앞에 async를 붙이면 그 함수는 <span style='color:skyBlue'>항상 Promise를 반환</span>함
- 함수 내부에서 return을 사용하면 자동으로 resolve(return값)가
  적용되어 Promise로 감싸져 반환됨

## await 키워드

- await 키워드는 Promise가 완료될 때까지 비동기 작업을 <span style='color:skyBlue'>기다린
  후 다음 코드 실행</span>
- await는 async 함수 내부에서만 사용 가능

```js
function getData() {
  return new Promise((resolve) => {
    setTimeout(() => resolve('Hello'), 1000);
  });
}

// Promise then 체인
getData().then((msg) => {
  console.log(msg); // "Hello"
});
console.log('End');
// 실행 순서: End → “Hello"
// 위 처럼 프로미스 체인은 콜백 지옥 문제를 해결했지만 코드 실행 순서를 직관적으로 이해하기에는 여전히 어려움

// async/await 버전
async function getDataAsync() {
  const msg = await getData();
  console.log(msg); // “Hello"
  console.log('End');
}
getDataAsync();
// 실행 순서: "Hello" → End
```

## async, await 실행 흐름 이해하기

```js
async function example() {
  console.log('Before await');

  const result = await new Promise((resolve) => {
    // 2초 후에 resolve 호출
    setTimeout(() => resolve('Async result'), 2000);
  });

  console.log('After await:', result);
}

example();
console.log('Outside async function');

// 출력
// Before await
// Outside async function
// (2초 후)
// After await: Async result
```

**await를 만나면 Promise가 끝날 때까지 다음 코드를 실행하지 않는다. await 이후의 코드는 then으로 후속 처리를 할 때와 마찬가지로 통째로 마이크로태스크 큐에 들어간다.**

1. example() 호출
   - example 함수가 실행되면서 콜 스택에 추가됨
   - "Before await" 출력됨
2. await를 만나면서 비동기 처리 시작
   - setTimeout이 실행됨 (2초 후 resolve 호출)
   - 이 시점에서 example 함수는 대기 상태(await에서 멈춤)
   - example의 실행 컨텍스트가 콜 스택에서 제거됨
3. console.log("Outside async function") 실행
   - example 함수가 멈춘 상태이므로 다음 코드가 바로 실행됨
   - "Outside async function" 출력됨
4. 2초 후 setTimeout 완료 → Promise가 resolve("Async result") 호출
   - resolve가 호출되면서 마이크로태스크 큐에 example의 남은 코드(console.log("After await:", result))가 추가됨
5. 이벤트 루프가 마이크로태스크 큐를 확인하고 실행
   - "After await: Async result" 출력됨
