## 콜백 함수와 콜백 지옥

### 비동기 콜백 함수

- **비동기 작업이 끝난 뒤 실행될 로직을 넘기기 위해 사용하는 함수.**
- 비동기 함수는 작업이 완료되는 시점을 예측할 수 없기 때문에, 완료 후 실행할 행동을 함수 형태로 전달하는 방식이 필요함.
- 예를 들어 서버에서 데이터를 받아오거나 타이머가 끝나기를 기다리는 작업에서 다음 동작을 안전하게 실행하기 위해 사용됨.

### 비동기 콜백이 필요한 이유

- 아래 코드의 예시처럼 비동기 함수 내부에서 데이터를 리턴하면, 비동기 작업이 완료되기 전에 리턴되므로 결과를 받을 수 없음

```js
function fetchData() {
  let data;
  setTimeout(() => {
    data = 'Hello, World!';
  }, 1000);

  return data; // 비동기 작업 완료 전 반환되므로 undefined
}

const result = fetchData();
console.log(result); // undefined
```

이 문제 때문에 **비동기 작업이 끝난 시점**에 수행될 코드를 콜백으로 전달해야 함:

```js
function fetchData(callback) {
  setTimeout(() => {
    const data = 'Hello, World!';
    callback(data); // 비동기 작업 완료 후 콜백 호출
  }, 1000);
}

fetchData((result) => {
  console.log(result); // "Hello, World!"
});
```

"비동기 작업은 언제 끝날지 모르니, 끝난 뒤 할 일을 나한테 알려줘." 라는 방식.

### 콜백 지옥 (콜백 헬)

- 방식으로 비동기 작업을 여러 번 수행하면, 코드가 계속 중첩되어 가독성이 떨어짐
- 깊은 중첩으로 인해 코드 관리와 디버깅이 어려워지는 현상
- 이런 콜백 지옥 문제를 해결하기 위해 Promise가 도입됨

### 콜백 지옥(CallBack Hell)이 발생하는 이유

비동기 작업이 하나라면 간단하지만,
아래처럼 결과를 기반으로 다음 비동기 작업을 연달아 수행해야 하는 경우가 문제:

```js
function fetchData(callback) {
  setTimeout(() => {
    const data = 'Hello, World!';
    callback(data); // 데이터를 콜백 함수로 전달
  }, 1000);
}

// 콜백 함수가 중첩되는 상황
fetchData((result1) => {
  console.log('First:', result1);
  fetchData((result2) => {
    console.log('Second:', result2);
    fetchData((result3) => {
      console.log('Third:', result3);
    });
  });
});
```

또는 서버 요청이 순차적 의존성을 가진 경우:

```js
get(`${url}/posts/1`, (userId) => {
  get(`${url}/users/${userId}`, (userInfo) => {
    get(`${url}/grades/${userInfo.grade}/benefits`, (benefits) => {
      console.log(`User ${userId} Benefits: ${benefits}`);
    });
  });
});
```

이렇게 되면…

- 들여쓰기 깊어짐 (피라미드 구조)

- 에러 처리 어려움

- 흐름 파악 어려움

- 재사용성 떨어짐

- 유지보수가 비효율적

정리하면 **순서를 지켜야 하는 복잡한 비동기 흐름일수록 구조가 깊어지고 가독성이 심각하게 떨어지는 현상이** 콜백 지옥이다.

## 🚨 주의) 모든 콜백 함수가 비동기 콜백 함수가 아니다.

콜백은 단순히 <strong>“다른 함수에 전달되어 나중에 실행되는 함수”</strong>라는 개념이기 때문에 <strong>동기(synchronous)</strong> 콜백도 존재함

### 동기 콜백과 비동기 콜백의 차이

### 1. 동기 콜백 (Synchronous Callback)

- 즉시 실행됨.

- 현재 실행 흐름을 멈추고, 콜백을 실행한 뒤 다음 코드로 이동함.

- 배열 메서드(map, filter, reduce 등)에서 쓰는 콜백이 대표적 예시.

```js
const numbers = [1, 2, 3];

const doubled = numbers.map((num) => {
  return num \* 2; // 동기 콜백: map 호출 도중 바로 실행됨
});

console.log(doubled); // [2, 4, 6]
```

위 콜백은 호출되는 즉시 실행되기 때문에 비동기와 달리 흐름 제어가 단순함.

### 2. 비동기 콜백 (Asynchronous Callback)

- 작업이 완료된 시점에 실행됨.

- 예측할 수 없는 시점에 호출됨.

- setTimeout, addEventListener, 서버 요청 등의 후속 작업에서 실행됨.

```js
setTimeout(() => {
  console.log('이 콜백은 나중에 실행됨');
}, 1000);
```

### 3. 콜백 지옥은 반드시 비동기 맥락에서만 발생

- 콜백 지옥은 <strong>“순서를 지켜야 하는 비동기 작업이 연달아 있을 때”</strong> 발생하는 구조 문제이기 때문에 동기 콜백에서는 거의 발생하지 않음

동기 콜백에서는:

- 실행 시점이 명확하고,

- 순차 실행이 보장됨

그래서 콜백이 여러 번 중첩되더라도 흐름이 단순하기 때문에 “지옥”처럼 복잡해지지 않음.
