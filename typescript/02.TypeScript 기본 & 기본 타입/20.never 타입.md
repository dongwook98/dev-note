# never 타입 핵심 정리

## never란?

- 특정 함수가 **절대 값을 반환하지 않을 때** 사용되는 타입.

- 실행이 끝까지 도달하지 않는 함수의 반환 타입.

## 언제 never가 등장하는가

- **항상 오류를 던지는 함수**

  - 예: throw로 실행을 중단하는 함수

- 무한 루프 함수

  - 예: while(true)로 끝나지 않는 함수

## void와의 차이

- void: 반환값이 없는 함수지만, 정상적으로 종료는 된다
  (예: 로그 출력 함수)

- never: 함수가 정상적으로 종료되지도 않고,
  반환값 자체가 존재할 수 없다
  (예: 오류를 던져 실행 자체가 멈춤)

## 예시 코드

```ts
function generateError(message: string, code: number): never {
  throw { message, errorCode: code };
}

console.log(generateError('에러 발생함!', 500));
// undefined도 출력안되고 에러 발생
// throw가 실행되는 순간 스크립트 흐름이 중단되므로
// console.log가 처리할 “반환값” 자체가 존재하지 않는다.

// 즉, print할 값이 없어서 undefined가 찍히는 게 아니라,
// 애초에 console.log 호출 자체가 실행되지 않는다.
```

- 위 함수는 항상 오류를 던지기 때문에 절대 반환값을 만들지 않는다.

- 그래서 never가 함수의 반환 타입으로 적합하다.

## try–catch로 감쌀 때 어떤 일이 일어날까?

- try–catch로 감싸면 흐름이 완전히 달라집니다.
  핵심은 함수 내부에서는 여전히 never이지만, throw가 외부 catch에서 처리되면 전체 스크립트 흐름이 끊기지 않는다.

```ts
function generateError(message: string, code: number): never {
  throw { message, errorCode: code };
}

try {
  generateError('에러 발생함!', 500);
  console.log('여기는 실행될까?'); // ①
} catch (err) {
  console.log('catch로 에러 받음:', err); // ②
}

console.log('try-catch 이후 코드'); // ③
```

## 실행 흐름

- `generateError`에서 `throw`가 발생하면 **즉시 try 블록을 빠져나감**

- ①의 코드는 절대 실행되지 않음

- 던진 값 (`{ message, errorCode }`)이 catch로 전달됨 → ② 실행

- catch가 실행된 후, ③ 코드도 정상적으로 실행됨
  → 즉, **프로그램 전체 흐름은 멈추지 않는다**

## 출력 결과 예시

```ts
catch로 에러 받음: { message: "에러 발생함!", errorCode: 500 }
try-catch 이후 코드
```

## 왜 명시적으로 never를 쓰는가

- 코드 의도를 명확하게 드러낼 수 있다.

- “이 함수는 절대 정상적으로 끝나지 않는다”는 정보를 다른 개발자에게 전달.
